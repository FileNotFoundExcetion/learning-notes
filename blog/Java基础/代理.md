**代理：**

1. 动态代理（基于接口）
2. 静态代理
3. CGLIB代理（基于字节码）

代理模式一般涉及到的角色有：

- 抽象角色：声明真实对象和代理对象的共同接口
- 代理角色：代理角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象与真实对象提供相同的接口以便在任何时刻代替真实对象
- 真实角色：代理角色所代表的的真实对象，最终所要引用的对象

**静态代理**：代理对象含有真实对象的引用，从而可以操作真实对象（代理类一般可以是一个抽象类或者是一个接口，由真实类和代理共同实现它，相当于对真实对象的封装）

优点：在不修改目标对象的前提下扩展

缺点：接口增加新的方法，代理类也随之要增加，代理类一多，就比较臃肿



**JDK动态代理（解决静态代理接口过多的问题，通过反射实现的）**

1.编写一个接口（真实对象实现它）

2.创建一个动态代理类，实现InvocationHandler接口，动态代理类含有这真实对象的引用，这里通常是private Object object；此处的Object就是真实对象的引用

代码的关键：

Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler handler) 返回的是一个接口（真实对象实现的接口）的引用

- loader:代理对象的类加载器（对象调用getClass方法在调用classLoader方法）
- interfaces:代理对象需要实现的接口，可以指定多个接口new class[]{真实对象实现的接口.class};
- hanldler:方法调用的实际处理者，代理对象的处理都会转发至此，所谓的动态代理类的引用
- classLoader的作用就是将字节码加载进虚拟机并生成相应的class对象



**CGLIB代理**

1.首先要实现MethodInterceptor接口

2.通过Enhancer来代理，最终通过create方法得到代理对象



原理：底层通过一个小而快的字节码处理包ASM，在运行期间扩展Java类和实现Java接口

创建代理对象的几个步骤：

1.生成代理类的二进制字节码文件

2加载二进制字节码，生成class对象

3.通过反射机制获得实例构造



**总结：**

1.JDK动态代理：利用拦截器实现，加上反射机制生成一个匿名接口代理类，实现了对接口的动态代理

2.CGLIB：利用ASM开源包

3.选择：

1.实现接口，采用动态代理

2.实现了接口，可以强使用CGLIB实现

3.没有实现接口，必须采用CGLIB实现，Spring会自动在CGLIB和JDK动态代理之间转换





