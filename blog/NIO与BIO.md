BIO缺点：编码方式必须是一个客户端对应一个线程，线程开启太多导致服务器崩掉，对线程资源的浪费。

对于客户端的何时连接以及客户端的发送数据，这些我们是不知道的（BIO）

NIO把阻塞的地方去掉了（accept和read方法）

提供selector对象（服务端的socket或者服务端接收到的客户端的socket注册在selector中，并指定感兴趣的事件），注册事件（理解）。。

服务端socket感兴趣的是客户端连接事件（accept事件）

客户端socket感兴趣的是客户端是否发来了数据（read事件）

nio是通过事件去调用方法，提升了效率，而bio是直接一直调用方法，将发生死循环

NIO会轮询注册的事件，select是阻塞的

Reactor模式：注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。

NIO给我们带来了些什么：

> - 事件驱动模型
> - 避免多线程
> - 单线程处理多任务
> - 非阻塞I/O，I/O读写不再阻塞，而是返回0
> - 基于block的传输，通常比基于流的传输更高效
> - 更高级的IO函数，zero-copy
> - IO多路复用大大提高了Java网络应用的可伸缩性和实用性

#### 标准/典型的Reactor：

- 步骤1：等待事件到来（Reactor负责）。
- 步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）。
- 步骤3：读数据（用户处理器负责）。
- 步骤4：处理数据（用户处理器负责）

**注意：selector的底层实现，根据不同的操作系统来实现，Windows底层依赖select函数，linux依赖于epoll函数。**
