GC回收的对象是堆空间和永久代 

1.标记-清除（CMS垃圾收集器）

标记清除算法分为2个阶段：标记和清除阶段。在标记阶段，先通过根节点，标记所有从根节点开始的可达对象（可达性分析）。未标记的对象就是未被引用的对象，随之在清除阶段清除所有未标记的对象

缺点：

- 效率问题，标记和清除2个过程的效率都不高
- 空间问题，标记清除之后会产生大量的不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

2.标记-压缩（老年代）

基于标记清除算法做的一些优化，适用于存活对象较多的场所（老年代）。和标记-清除算法一样同样也需要从根节点开始，对所有可达对象进行标记。但是之后并不是简单清理未标记的对象，**而是将所有的存活对象压缩到一端**，清理边界外的空间

缺点：

和标记清除算法一样，效率不高

优点：

- 解决了内存碎片问题，相对于标记清除算法
- 没有内存碎片，对象创建内存分配速度更快了（可以使用TLAB分配）



3.复制算法（不适用于老年代）

通标记清除算法比也是一种高效的垃圾回收算法，**不适用于对象较多的场合**（老年代）

过程：将原有的内存空间分为2块，每次只使用其中的一块，每次在垃圾回收时，将正在使用内存中存活对象复制到未使用的内存块中，之后清除内存块中所有对象，交换2个内存的角色，完成垃圾回收。

优点：效率高，没有内存碎片

缺点：

浪费一半的空间

在对象存活率较高时采用复制算法，进行较多的复制操作，效率将会变低



4.分代垃圾回收算法

目的：使得JVM更好地管理堆内存中的对象，包括内存分配以及回收

根据对象的存活周期将堆分为：新生代和老年代

新生代分为：Eden区，From Survivor区和To Survivor