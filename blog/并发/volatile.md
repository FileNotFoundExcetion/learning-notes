1.成员变量，类的静态成员变量被volatile修饰之后，具备2层含义

- 保证了不同线程对这个变量进行操作的可见性，线程修改了某个变量的值，新值对于其他线程来说是可见的。（比synchronized的可见性成本低，不会引发起线程上下文的切换和调度）
- 禁止指令重排序

2.volatile定义（语言规范第3版）：

Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量  。

3.如何保证可见性

从汇编的角度来看

0x01a3de1d: movb $0x0,0x1104800(%esi);
0x01a3de24: lock addl $0x0,(%esp);  

- 有volatile变量修饰的共享变量进行写操作时会多出第二行汇编代码，Lock前缀的指令在多核处理器下
  会引发两个事：
  将当前处理器缓存行的数据写回到系统内存。
- 该写回到内存的操作会使在其他CPU里缓存了该内存地址的数据无效 。

4.实现原理：

- Lock前缀指令会引起处理器缓存回写到内存
- 一个处理器的缓存回写到内存会导致其他处理器的缓存无效  

5.volatile是不能保证原子性的

因为他不是锁，他没做任何可以保证原子性的处理。当然就不能保证原子性了。

6.volatile能够禁止指令重排也就保证了有序性

7.指令重排的实现：

volatile是通过内存屏障来禁止指令重排的

8.内存屏障（可以解决缓存的可见性）的定义：

内存屏障（Memory Barrier）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。下表描述了和volatile有关的指令重排禁止行为

写内存屏障（Store Memory Barrier）可以促使处理器将当前store buffer（存储缓存）的值写回主存。读内存屏障（Load Memory Barrier）可以促使处理器处理invalidate queue（失效队列）。进而避免由于Store Buffer和Invalidate Queue的非实时性带来的问题
